{"ast":null,"code":"/**\n * Christopher Flowers\n * @02856440\n * \n * Inspiration came from the following github repo\n * https://github.com/Enoumy/boggle/blob/02e43d606b87516a0ab4f25a0e8513aef7a68c66/src/boggle_solver.js\n * \n * Paired programming with Jurnee Tipton\n * \n *     run with 'node boggle_solver.js'\n * \n * Given a Boggle board and a dictionary, returns a list of available words in\n * the dictionary present inside of the Boggle board.\n * @param {string[][]} grid - The Boggle game board.\n * @param {string[]} dictionary - The list of available words.\n * @returns {string[]} solutions - Possible solutions to the Boggle board.\n */\n//boggle grid                \nconst grid = [['A', 'Qu'], ['C', 'D']]; //valid words\n\nconst dictionary = ['art', 'ego', 'gent', 'get', 'net', 'new', 'newt', 'prat', 'pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp', 'ten', 'went', 'wet', 'arty', 'egg', 'not', 'quar', 'ab', 'abd', 'dca', 'qac']; //positions of tiles adjacent to the selected tile\n\nconst adjacentTiles = [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]; //Node used to create the Trie structure\n\nclass Node {\n  constructor() {\n    this.children = {};\n    this.word = \"\";\n    this.parent = null;\n    this.end = false;\n  }\n\n} //Class to support tracking visited\n\n\nclass Coordinates {\n  constructor() {\n    this.coordinates = new Object();\n  } //adds (x,y) coordinate to the set\n\n\n  add(x, y) {\n    if (!Coordinates.hasOwnProperty.call(this.coordinates, x)) this.coordinates[x] = new Set();\n    this.coordinates[x].add(y);\n  } //deletes (x,y) coordiante from the set\n\n\n  delete(x, y) {\n    if (!Object.hasOwnProperty.call(this.coordinates, x)) return;\n    this.coordinates[x].delete(y);\n    if (this.coordinates[x].length === 0) delete this.coordinates[x];\n  } //checks to see if a (x,y) coordinate is already present in the set\n\n\n  has(x, y) {\n    if (!Object.hasOwnProperty.call(this.coordinates, x)) return false;\n    return this.coordinates[x].has(y);\n  }\n\n} //conducts a depth first search on the grid\n\n\nfunction depthFirstSearch(grid, x, y, trieNode, visited, originalMappings, solutions) {\n  if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || visited.has(x, y)) {\n    return;\n  }\n\n  if (!Object.hasOwnProperty.call(trieNode.children, grid[x][y].charAt(0))) {\n    return;\n  }\n\n  trieNode = trieNode.children[grid[x][y].charAt(0)]; // Checks full length of the grid space in case it has more than 1 character\n\n  let i = 1; // i is declared in the scope of the function to be used later.\n\n  for (; Object.hasOwnProperty.call(trieNode.children, grid[x][y].charAt(i)); i++) {\n    trieNode = trieNode.children[grid[x][y].charAt(i)];\n  } // If it has reached both the end of the cell and the trie's word...\n\n\n  if (i === grid[x][y].length && trieNode.isEnd) {\n    solutions.push(originalMappings[trieNode.word]);\n    trieNode.isEnd = false;\n  } else if (i != grid[x][y].length) {\n    trieNode.isEnd = false;\n  }\n\n  visited.add(x, y); // For each adjacent letter cell...\n\n  for (let direction = 0; direction < adjacentTiles.length; direction++) {\n    depthFirstSearch(grid, x + adjacentTiles[direction][0], // Adjacent tile.\n    y + adjacentTiles[direction][1], // Adjacent tile.\n    trieNode, visited, originalMappings, solutions);\n  }\n\n  visited.delete(x, y);\n} //creates a Trie given a list of words\n\n\nfunction createTrie(dictionary) {\n  let root = new Node();\n\n  for (let word = 0; word < dictionary.length; word++) {\n    if (dictionary[word].length >= 3) {\n      insertWord(root, dictionary[word]);\n    }\n  }\n\n  return root;\n} //inserts a word into the Trie given the root node\n\n\nfunction insertWord(root, word) {\n  let trie = root;\n\n  for (let char = 0; char < word.length; char++) {\n    if (!Object.hasOwnProperty.call(trie.children, word[char])) trie.children[word[char]] = new Node();\n    trie = trie.children[word[char]]; // console.log(trie.children)\n  }\n\n  trie.isEnd = true;\n  trie.word = word;\n} //converts all values in the grid to lowercase\n\n\nfunction loweCaseConversion(grid) {\n  for (let x = 0; x < grid.length; x++) for (let y = 0; y < grid[x].length; y++) grid[x][y] = grid[x][y].toLowerCase();\n} //creates a map containing each dictionary value\n\n\nfunction createWordMap(array) {\n  let originalMappings = new Object();\n\n  for (let i = 0; i < array.length; i++) {\n    originalMappings[array[i]] = array[i];\n  } // console.log(originalMappings)\n\n\n  return originalMappings;\n}\n\nexports.findAllSolutions = function (grid, dictionary) {\n  let solutions = []; //returns an empty array if the grid or dictionay are empty\n\n  if (grid.length == 0 || dictionary.length == 0) {\n    return [];\n  } //returns an empty array if grid is not a N x N matrix\n\n\n  for (let i = 0; i < grid.length; i++) {\n    if (grid.length != grid[i].length) {\n      return solutions = [];\n    }\n  }\n\n  var result = false;\n  let regEx1 = /(q[a-t]{1})|(q[v-z]{1})/;\n  grid.forEach(line => {\n    line.forEach(character => {\n      character = character.toLowerCase();\n      var test = regEx1.test(character);\n\n      if (test) {\n        result = true;\n      }\n    });\n  });\n\n  if (result == true) {\n    return [];\n  }\n\n  var test = false;\n  var result2 = false;\n  let regEx2 = /([a-p][a-z])|([r-z][a-z])/;\n  grid.forEach(line => {\n    line.forEach(character => {\n      character = character.toLowerCase();\n      test = regEx2.test(character);\n\n      if (test == true) {\n        console.log(\"here\");\n        result2 = true;\n      }\n    });\n    return;\n  });\n\n  if (result2 == true) {\n    return [];\n  }\n\n  loweCaseConversion(grid); //converts letters in the grid to be lower case\n\n  loweCaseConversion(dictionary); //converts letters in the dictionary to be lower ca\n\n  let originalMappings = createWordMap(dictionary);\n  let trie = createTrie(dictionary);\n\n  for (let x = 0; x < grid.length; x++) for (let y = 0; y < grid[x].length; y++) {\n    let visited = new Coordinates();\n    depthFirstSearch(grid, x, y, trie, visited, originalMappings, solutions);\n  }\n\n  return solutions;\n};\n\nconsole.log(exports.findAllSolutions(grid, dictionary));","map":{"version":3,"sources":["/Users/cmaur/Desktop/Software Engineering/boggle-react-app/src/Boggle Implementation/boggle_solver.js"],"names":["grid","dictionary","adjacentTiles","Node","constructor","children","word","parent","end","Coordinates","coordinates","Object","add","x","y","hasOwnProperty","call","Set","delete","length","has","depthFirstSearch","trieNode","visited","originalMappings","solutions","charAt","i","isEnd","push","direction","createTrie","root","insertWord","trie","char","loweCaseConversion","toLowerCase","createWordMap","array","exports","findAllSolutions","result","regEx1","forEach","line","character","test","result2","regEx2","console","log"],"mappings":"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","sourcesContent":["/**\n * Christopher Flowers\n * @02856440\n * \n * Inspiration came from the following github repo\n * https://github.com/Enoumy/boggle/blob/02e43d606b87516a0ab4f25a0e8513aef7a68c66/src/boggle_solver.js\n * \n * Paired programming with Jurnee Tipton\n * \n *     run with 'node boggle_solver.js'\n * \n * Given a Boggle board and a dictionary, returns a list of available words in\n * the dictionary present inside of the Boggle board.\n * @param {string[][]} grid - The Boggle game board.\n * @param {string[]} dictionary - The list of available words.\n * @returns {string[]} solutions - Possible solutions to the Boggle board.\n */\n\n\n\n//boggle grid                \nconst grid = [['A', 'Qu'],\n['C', 'D']];\n\n//valid words\nconst dictionary = ['art', 'ego', 'gent', 'get', 'net', 'new', 'newt', 'prat',\n    'pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp',\n    'ten', 'went', 'wet', 'arty', 'egg', 'not', 'quar', 'ab', 'abd', 'dca', 'qac'];\n\n//positions of tiles adjacent to the selected tile\nconst adjacentTiles =   [[-1, -1], [0, -1], [1, -1],\n                        [-1, 0], [1, 0],\n                        [-1, 1], [0, 1], [1, 1]];\n\n\n//Node used to create the Trie structure\nclass Node {\n    constructor() {\n        this.children = {};\n        this.word = \"\";\n        this.parent = null;\n        this.end = false;\n    }\n}\n\n\n//Class to support tracking visited\nclass Coordinates {\n    constructor() {\n        this.coordinates = new Object();\n    }\n\n    //adds (x,y) coordinate to the set\n    add(x, y) {\n        if (!Coordinates.hasOwnProperty.call(this.coordinates, x)) this.coordinates[x] = new Set();\n        this.coordinates[x].add(y);\n    }\n\n    //deletes (x,y) coordiante from the set\n    delete(x, y) {\n        if (!Object.hasOwnProperty.call(this.coordinates, x)) return;\n        this.coordinates[x].delete(y);\n        if (this.coordinates[x].length === 0) delete this.coordinates[x];\n    }\n\n    //checks to see if a (x,y) coordinate is already present in the set\n    has(x, y) {\n        if (!Object.hasOwnProperty.call(this.coordinates, x)) return false;\n        return this.coordinates[x].has(y);\n    }\n}\n\n//conducts a depth first search on the grid\nfunction depthFirstSearch(grid, x, y, trieNode, visited, originalMappings, solutions) {\n    if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || visited.has(x, y)) {\n        return;\n    }\n\n    if (!Object.hasOwnProperty.call(trieNode.children, grid[x][y].charAt(0))) {\n        return;\n    }\n\n    trieNode = trieNode.children[grid[x][y].charAt(0)];\n\n    // Checks full length of the grid space in case it has more than 1 character\n    let i = 1; // i is declared in the scope of the function to be used later.\n    for (; Object.hasOwnProperty.call(trieNode.children, grid[x][y].charAt(i)); i++) {\n        trieNode = trieNode.children[grid[x][y].charAt(i)];\n    }\n\n    // If it has reached both the end of the cell and the trie's word...\n    if (i === grid[x][y].length && trieNode.isEnd) {\n        solutions.push(originalMappings[trieNode.word]);\n        trieNode.isEnd = false;\n    }\n    else if (i != grid[x][y].length) {\n        trieNode.isEnd = false;\n    }\n\n    visited.add(x, y);\n\n    // For each adjacent letter cell...\n    for (let direction = 0; direction < adjacentTiles.length; direction++) {\n\n        depthFirstSearch(\n            grid,\n            x + adjacentTiles[direction][0], // Adjacent tile.\n            y + adjacentTiles[direction][1], // Adjacent tile.\n            trieNode,\n            visited,\n            originalMappings,\n            solutions\n        );\n    }\n    visited.delete(x, y);\n}\n\n//creates a Trie given a list of words\nfunction createTrie(dictionary) {\n    let root = new Node();\n    for (let word = 0; word < dictionary.length; word++) {\n        if (dictionary[word].length >= 3) {\n            insertWord(root, dictionary[word]);\n        }\n    }\n    return root;\n}\n\n\n\n//inserts a word into the Trie given the root node\nfunction insertWord(root, word) {\n    let trie = root;\n    for (let char = 0; char < word.length; char++) {\n        if (!Object.hasOwnProperty.call(trie.children, word[char])) \n        trie.children[word[char]] = new Node();\n        trie = trie.children[word[char]];\n        // console.log(trie.children)\n    }\n    trie.isEnd = true;\n    trie.word = word;\n}\n\n//converts all values in the grid to lowercase\nfunction loweCaseConversion(grid) {\n    for (let x = 0; x < grid.length; x++)\n        for (let y = 0; y < grid[x].length; y++)\n            grid[x][y] = grid[x][y].toLowerCase();\n}\n\n//creates a map containing each dictionary value\nfunction createWordMap(array) {\n    let originalMappings = new Object();\n    for (let i = 0; i < array.length; i++) {\n        originalMappings[array[i]] = array[i];\n    }\n    // console.log(originalMappings)\n    return originalMappings;\n}\n\n\nexports.findAllSolutions = function (grid, dictionary) {\n\n    let solutions = [];\n\n    //returns an empty array if the grid or dictionay are empty\n    if (grid.length == 0 || dictionary.length == 0) {\n        return [];\n    }\n\n    //returns an empty array if grid is not a N x N matrix\n    for (let i = 0; i < grid.length; i++) {\n        if (grid.length != grid[i].length) {\n            return solutions = [];\n        }\n    }\n    \n    var result = false;\n    let regEx1 = /(q[a-t]{1})|(q[v-z]{1})/;\n    grid.forEach(line => {\n        line.forEach(character => {\n\n            character = character.toLowerCase();\n            var test = regEx1.test(character);\n            if(test) {\n                result = true;\n            }\n        });\n    });\n\n    if(result == true) {\n        return [];\n    }\n    \n    var test = false;\n    var result2 = false;\n    let regEx2 = /([a-p][a-z])|([r-z][a-z])/;\n    grid.forEach(line => {\n        line.forEach(character => {\n\n            character = character.toLowerCase();\n            test = regEx2.test(character);\n            if (test == true) {\n                console.log(\"here\");\n                result2 = true;\n            }\n        });\n\n        return;\n        \n    });\n\n        if(result2 == true) {\n            return [];\n        }\n\n    loweCaseConversion(grid); //converts letters in the grid to be lower case\n    loweCaseConversion(dictionary); //converts letters in the dictionary to be lower ca\n    let originalMappings = createWordMap(dictionary);\n\n    let trie = createTrie(dictionary);\n\n    for (let x = 0; x < grid.length; x++)\n        for (let y = 0; y < grid[x].length; y++) {\n            let visited = new Coordinates();\n            depthFirstSearch(grid, x, y, trie, visited, originalMappings, solutions);\n        }\n\n    return solutions;\n};\n\n\n\n\nconsole.log(exports.findAllSolutions(grid, dictionary ));\n\n\n"]},"metadata":{},"sourceType":"module"}