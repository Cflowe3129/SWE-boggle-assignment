{"ast":null,"code":"/**\n * Christopher Flowers\n * @02856440\n * \n * Inspiration came from the following github repo\n * https://github.com/Enoumy/boggle/blob/02e43d606b87516a0ab4f25a0e8513aef7a68c66/src/boggle_solver.js\n * \n * Paired programming with Jurnee Tipton\n * \n *     run with 'node boggle_solver.js'\n * \n * Given a Boggle board and a dictionary, returns a list of available words in\n * the dictionary present inside of the Boggle board.\n * @param {string[][]} grid - The Boggle game board.\n * @param {string[]} dictionary - The list of available words.\n * @returns {string[]} solutions - Possible solutions to the Boggle board.\n */\n// //boggle grid                \n// const grid = [['A', 'Qu'],\n// ['C', 'D']];\n// //valid words\n// const dictionary = ['art', 'ego', 'gent', 'get', 'net', 'new', 'newt', 'prat',\n//     'pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp',\n//     'ten', 'went', 'wet', 'arty', 'egg', 'not', 'quar', 'ab', 'abd', 'dca', 'qac'];\n//positions of tiles adjacent to the selected tile\nconst adjacentTiles = [[-1, -1], [0, -1], [1, -1], [-1, 0], [1, 0], [-1, 1], [0, 1], [1, 1]]; //Node used to create the Trie structure\n\nclass Node {\n  constructor() {\n    this.children = {};\n    this.word = \"\";\n    this.parent = null;\n    this.end = false;\n  }\n\n} //Class to support tracking visited\n\n\nclass Coordinates {\n  constructor() {\n    this.coordinates = new Object();\n  } //adds (x,y) coordinate to the set\n\n\n  add(x, y) {\n    if (!Coordinates.hasOwnProperty.call(this.coordinates, x)) this.coordinates[x] = new Set();\n    this.coordinates[x].add(y);\n  } //deletes (x,y) coordiante from the set\n\n\n  delete(x, y) {\n    if (!Object.hasOwnProperty.call(this.coordinates, x)) return;\n    this.coordinates[x].delete(y);\n    if (this.coordinates[x].length === 0) delete this.coordinates[x];\n  } //checks to see if a (x,y) coordinate is already present in the set\n\n\n  has(x, y) {\n    if (!Object.hasOwnProperty.call(this.coordinates, x)) return false;\n    return this.coordinates[x].has(y);\n  }\n\n} //conducts a depth first search on the grid\n\n\nfunction depthFirstSearch(grid, x, y, trieNode, visited, originalMappings, solutions) {\n  if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || visited.has(x, y)) {\n    return;\n  }\n\n  if (!Object.hasOwnProperty.call(trieNode.children, grid[x][y].charAt(0))) {\n    return;\n  }\n\n  trieNode = trieNode.children[grid[x][y].charAt(0)]; // Checks full length of the grid space in case it has more than 1 character\n\n  let i = 1; // i is declared in the scope of the function to be used later.\n\n  for (; Object.hasOwnProperty.call(trieNode.children, grid[x][y].charAt(i)); i++) {\n    trieNode = trieNode.children[grid[x][y].charAt(i)];\n  } // If it has reached both the end of the cell and the trie's word...\n\n\n  if (i === grid[x][y].length && trieNode.isEnd) {\n    solutions.push(originalMappings[trieNode.word]);\n    trieNode.isEnd = false;\n  } else if (i != grid[x][y].length) {\n    trieNode.isEnd = false;\n  }\n\n  visited.add(x, y); // For each adjacent letter cell...\n\n  for (let direction = 0; direction < adjacentTiles.length; direction++) {\n    depthFirstSearch(grid, x + adjacentTiles[direction][0], // Adjacent tile.\n    y + adjacentTiles[direction][1], // Adjacent tile.\n    trieNode, visited, originalMappings, solutions);\n  }\n\n  visited.delete(x, y);\n} //creates a Trie given a list of words\n\n\nfunction createTrie(dictionary) {\n  let root = new Node();\n\n  for (let word = 0; word < dictionary.length; word++) {\n    if (dictionary[word].length >= 3) {\n      insertWord(root, dictionary[word]);\n    }\n  }\n\n  return root;\n} //inserts a word into the Trie given the root node\n\n\nfunction insertWord(root, word) {\n  let trie = root;\n\n  for (let char = 0; char < word.length; char++) {\n    if (!Object.hasOwnProperty.call(trie.children, word[char])) trie.children[word[char]] = new Node();\n    trie = trie.children[word[char]]; // console.log(trie.children)\n  }\n\n  trie.isEnd = true;\n  trie.word = word;\n} //converts all values in the grid to lowercase\n\n\nfunction loweCaseConversion(grid) {\n  for (let x = 0; x < grid.length; x++) for (let y = 0; y < grid[x].length; y++) grid[x][y] = grid[x][y].toLowerCase();\n} //creates a map containing each dictionary value\n\n\nfunction createWordMap(array) {\n  let originalMappings = new Object();\n\n  for (let i = 0; i < array.length; i++) {\n    originalMappings[array[i]] = array[i];\n  } // console.log(originalMappings)\n\n\n  return originalMappings;\n}\n\nexports.findAllSolutions = function (grid, dictionary) {\n  let solutions = []; //returns an empty array if the grid or dictionay are empty\n\n  if (grid.length == 0 || dictionary.length == 0) {\n    return [];\n  } //returns an empty array if grid is not a N x N matrix\n\n\n  for (let i = 0; i < grid.length; i++) {\n    if (grid.length != grid[i].length) {\n      return solutions = [];\n    }\n  } // //checks to see if Qx; where x is any non-u letter exists\n  // var result = false;\n  // let regEx1 = /(q[a-t]{1})|(q[v-z]{1}|(Q[A-T]{1})|(Q[V-Z]{1}))/;\n  // grid.forEach(line => {\n  //     line.forEach(character => {\n  //         character = character.toLowerCase();\n  //         var test = regEx1.test(character);\n  //         if(test) {\n  //             result = true;\n  //         }\n  //     });\n  // });\n  // if(result == true) {\n  //     return [];\n  // }\n  // var test = false;\n  // var result2 = false;\n  // let regEx2 = /([a-p][a-z])|([r-z][a-z]|([A-P][A-Z])|([R-Z][A-Z]))/;\n  // grid.forEach(line => {\n  //     line.forEach(character => {\n  //         character = character.toLowerCase();\n  //         test = regEx2.test(character);\n  //         if (test == true) {\n  //             console.log(\"here\");\n  //             result2 = true;\n  //         }\n  //     });\n  //     return;\n  // });\n\n\n  if (result2 == true) {\n    return [];\n  }\n\n  loweCaseConversion(grid); //converts letters in the grid to be lower case\n\n  loweCaseConversion(dictionary); //converts letters in the dictionary to be lower ca\n\n  let originalMappings = createWordMap(dictionary);\n  let trie = createTrie(dictionary);\n\n  for (let x = 0; x < grid.length; x++) for (let y = 0; y < grid[x].length; y++) {\n    let visited = new Coordinates();\n    depthFirstSearch(grid, x, y, trie, visited, originalMappings, solutions);\n  }\n\n  return solutions;\n};\n\nexports.findAllSolutions([], []);","map":{"version":3,"sources":["/Users/cmaur/Desktop/Software Engineering/boggle-react-app/src/Boggle Implementation/boggle_solver.js"],"names":["adjacentTiles","Node","constructor","children","word","parent","end","Coordinates","coordinates","Object","add","x","y","hasOwnProperty","call","Set","delete","length","has","depthFirstSearch","grid","trieNode","visited","originalMappings","solutions","charAt","i","isEnd","push","direction","createTrie","dictionary","root","insertWord","trie","char","loweCaseConversion","toLowerCase","createWordMap","array","exports","findAllSolutions","result2"],"mappings":"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","sourcesContent":["/**\n * Christopher Flowers\n * @02856440\n * \n * Inspiration came from the following github repo\n * https://github.com/Enoumy/boggle/blob/02e43d606b87516a0ab4f25a0e8513aef7a68c66/src/boggle_solver.js\n * \n * Paired programming with Jurnee Tipton\n * \n *     run with 'node boggle_solver.js'\n * \n * Given a Boggle board and a dictionary, returns a list of available words in\n * the dictionary present inside of the Boggle board.\n * @param {string[][]} grid - The Boggle game board.\n * @param {string[]} dictionary - The list of available words.\n * @returns {string[]} solutions - Possible solutions to the Boggle board.\n */\n\n\n\n// //boggle grid                \n// const grid = [['A', 'Qu'],\n// ['C', 'D']];\n\n// //valid words\n// const dictionary = ['art', 'ego', 'gent', 'get', 'net', 'new', 'newt', 'prat',\n//     'pry', 'qua', 'quart', 'quartz', 'rat', 'tar', 'tarp',\n//     'ten', 'went', 'wet', 'arty', 'egg', 'not', 'quar', 'ab', 'abd', 'dca', 'qac'];\n\n//positions of tiles adjacent to the selected tile\nconst adjacentTiles =   [[-1, -1], [0, -1], [1, -1],\n                        [-1, 0], [1, 0],\n                        [-1, 1], [0, 1], [1, 1]];\n\n\n//Node used to create the Trie structure\nclass Node {\n    constructor() {\n        this.children = {};\n        this.word = \"\";\n        this.parent = null;\n        this.end = false;\n    }\n}\n\n\n//Class to support tracking visited\nclass Coordinates {\n    constructor() {\n        this.coordinates = new Object();\n    }\n\n    //adds (x,y) coordinate to the set\n    add(x, y) {\n        if (!Coordinates.hasOwnProperty.call(this.coordinates, x)) this.coordinates[x] = new Set();\n        this.coordinates[x].add(y);\n    }\n\n    //deletes (x,y) coordiante from the set\n    delete(x, y) {\n        if (!Object.hasOwnProperty.call(this.coordinates, x)) return;\n        this.coordinates[x].delete(y);\n        if (this.coordinates[x].length === 0) delete this.coordinates[x];\n    }\n\n    //checks to see if a (x,y) coordinate is already present in the set\n    has(x, y) {\n        if (!Object.hasOwnProperty.call(this.coordinates, x)) return false;\n        return this.coordinates[x].has(y);\n    }\n}\n\n//conducts a depth first search on the grid\nfunction depthFirstSearch(grid, x, y, trieNode, visited, originalMappings, solutions) {\n    if (x < 0 || y < 0 || x >= grid.length || y >= grid[x].length || visited.has(x, y)) {\n        return;\n    }\n\n    if (!Object.hasOwnProperty.call(trieNode.children, grid[x][y].charAt(0))) {\n        return;\n    }\n\n    trieNode = trieNode.children[grid[x][y].charAt(0)];\n\n    // Checks full length of the grid space in case it has more than 1 character\n    let i = 1; // i is declared in the scope of the function to be used later.\n    for (; Object.hasOwnProperty.call(trieNode.children, grid[x][y].charAt(i)); i++) {\n        trieNode = trieNode.children[grid[x][y].charAt(i)];\n    }\n\n    // If it has reached both the end of the cell and the trie's word...\n    if (i === grid[x][y].length && trieNode.isEnd) {\n        solutions.push(originalMappings[trieNode.word]);\n        trieNode.isEnd = false;\n    }\n    else if (i != grid[x][y].length) {\n        trieNode.isEnd = false;\n    }\n\n    visited.add(x, y);\n\n    // For each adjacent letter cell...\n    for (let direction = 0; direction < adjacentTiles.length; direction++) {\n\n        depthFirstSearch(\n            grid,\n            x + adjacentTiles[direction][0], // Adjacent tile.\n            y + adjacentTiles[direction][1], // Adjacent tile.\n            trieNode,\n            visited,\n            originalMappings,\n            solutions\n        );\n    }\n    visited.delete(x, y);\n}\n\n//creates a Trie given a list of words\nfunction createTrie(dictionary) {\n    let root = new Node();\n    for (let word = 0; word < dictionary.length; word++) {\n        if (dictionary[word].length >= 3) {\n            insertWord(root, dictionary[word]);\n        }\n    }\n    return root;\n}\n\n\n\n//inserts a word into the Trie given the root node\nfunction insertWord(root, word) {\n    let trie = root;\n    for (let char = 0; char < word.length; char++) {\n        if (!Object.hasOwnProperty.call(trie.children, word[char])) \n        trie.children[word[char]] = new Node();\n        trie = trie.children[word[char]];\n        // console.log(trie.children)\n    }\n    trie.isEnd = true;\n    trie.word = word;\n}\n\n//converts all values in the grid to lowercase\nfunction loweCaseConversion(grid) {\n    for (let x = 0; x < grid.length; x++)\n        for (let y = 0; y < grid[x].length; y++)\n            grid[x][y] = grid[x][y].toLowerCase();\n}\n\n//creates a map containing each dictionary value\nfunction createWordMap(array) {\n    let originalMappings = new Object();\n    for (let i = 0; i < array.length; i++) {\n        originalMappings[array[i]] = array[i];\n    }\n    // console.log(originalMappings)\n    return originalMappings;\n}\n\n\nexports.findAllSolutions = function (grid, dictionary) {\n\n    let solutions = [];\n\n    //returns an empty array if the grid or dictionay are empty\n    if (grid.length == 0 || dictionary.length == 0) {\n        return [];\n    }\n\n    //returns an empty array if grid is not a N x N matrix\n    for (let i = 0; i < grid.length; i++) {\n        if (grid.length != grid[i].length) {\n            return solutions = [];\n        }\n    }\n    \n    // //checks to see if Qx; where x is any non-u letter exists\n    // var result = false;\n    // let regEx1 = /(q[a-t]{1})|(q[v-z]{1}|(Q[A-T]{1})|(Q[V-Z]{1}))/;\n    // grid.forEach(line => {\n    //     line.forEach(character => {\n\n    //         character = character.toLowerCase();\n    //         var test = regEx1.test(character);\n    //         if(test) {\n    //             result = true;\n    //         }\n    //     });\n    // });\n\n    // if(result == true) {\n    //     return [];\n    // }\n    \n    // var test = false;\n    // var result2 = false;\n    // let regEx2 = /([a-p][a-z])|([r-z][a-z]|([A-P][A-Z])|([R-Z][A-Z]))/;\n    // grid.forEach(line => {\n    //     line.forEach(character => {\n\n    //         character = character.toLowerCase();\n    //         test = regEx2.test(character);\n    //         if (test == true) {\n    //             console.log(\"here\");\n    //             result2 = true;\n    //         }\n    //     });\n\n    //     return;\n        \n    // });\n\n        if(result2 == true) {\n            return [];\n        }\n\n    loweCaseConversion(grid); //converts letters in the grid to be lower case\n    loweCaseConversion(dictionary); //converts letters in the dictionary to be lower ca\n    let originalMappings = createWordMap(dictionary);\n\n    let trie = createTrie(dictionary);\n\n    for (let x = 0; x < grid.length; x++)\n        for (let y = 0; y < grid[x].length; y++) {\n            let visited = new Coordinates();\n            depthFirstSearch(grid, x, y, trie, visited, originalMappings, solutions);\n        }\n\n    return solutions;\n};\n\n\n\n\nexports.findAllSolutions([], []);\n\n\n"]},"metadata":{},"sourceType":"module"}